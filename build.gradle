description = """\n
Importiert Nutzungsplanungs-INTERLIS-Daten in die Datenbank
und baut diese in das Publikationsmodell um.

Momentan wird noch nicht parametrisiert (also pro Gemeinde)
umgebaut, sondern immer der gesamte Datensatz als Quelle
verwendet. Der parametrisierte Umbau kann erst erfolgen,
wenn die benötigten GRETL-Steps dies unterstützen.

Die Performance des Umbau-Schrittes dürfte bei erst wenig
vorhandenen Gemeinden in der Quell-Datenbank nicht
problematisch sein.

'gradle importDataset -Pxtf=bfsnr_gemeindename.xtf'
"""

apply plugin: 'ch.so.agi.gretl'

ext {
    dbUrl = "jdbc:postgresql://geodb-dev.cgjofbdf5rqg.eu-central-1.rds.amazonaws.com:5432/xanadu2"
    dbUser = "stefan"
    dbPass = System.env.dbPass
    setNonExistingPropertyToUndefinedValue('xtf')
}

import ch.so.agi.gretl.tasks.*
import ch.so.agi.gretl.steps.*

task checkXtfName() {
    description = "Prüft, ob die ersten vier Buchstaben im XTF-Filenamen einer Nummer entsprechen, die im BfS-Range des Kt. SO liegt."    
    doFirst {
        def bfsRange = 2401..2622
        def bfsNr = xtf.take(4) as int
        assert true == bfsRange.contains(bfsNr)
    }
}

task validateDataset(type: IliValidator) {
    description = "Validiert ein Datensatz (=XTF)."    
    dataFiles = [xtf]
}

// Momentan noch *mit* Validierung.
// Bis klar ist, was IliValidator-Task genau macht.
task replaceDataset (type: Ili2pgReplace, dependsOn: 'checkXtfName') {
    description = "Ersetzt einen Datensatz (=XTF) in der PostgreSQL-Datenbank."
    database = [dbUrl, dbUser, dbPass]
    dbschema = "arp_npl"
    models = "SO_Nutzungsplanung_20170915"
    disableValidation = true
    dataset = xtf.take(4)
    dataFile = file(xtf)   
}

task transformArpNpl(type: Db2DbTask) {
    description = "Datenumbau in das Publikationsmodell."
    sourceDb =  [dbUrl, dbUser, dbPass]
    targetDb = [dbUrl, dbUser, dbPass]
    transferSets = [
            //new TransferSet("sql/transform_arp_npl_pub_nutzungsplanung_grundnutzung.sql", 'arp_npl_pub.nutzungsplanung_grundnutzung', true)
            //new TransferSet("sql/transform_arp_npl_pub_nutzungsplanung_ueberlagernd_flaeche.sql", 'arp_npl_pub.nutzungsplanung_ueberlagernd_flaeche', true)
            //new TransferSet("sql/transform_arp_npl_pub_nutzungsplanung_ueberlagernd_linie.sql", 'arp_npl_pub.nutzungsplanung_ueberlagernd_linie', true)
            //new TransferSet("sql/transform_arp_npl_pub_nutzungsplanung_ueberlagernd_punkt.sql", 'arp_npl_pub.nutzungsplanung_ueberlagernd_punkt', true)
            new TransferSet("sql/transform_arp_npl_pub_nutzungsplanung_beschriftung.sql", 'arp_npl_pub.nutzungsplanung_nutzungsplanung_beschriftung', true)
    ]
}


def setNonExistingPropertyToUndefinedValue(propertyName){
    setNonExistingPropertyToDefaultValue(propertyName, 'UNDEFINED')
}

def setNonExistingPropertyToDefaultValue(propertyName, defaultValue) {
    if (!project.hasProperty(propertyName)) {
        ext[propertyName] = defaultValue
    }
}